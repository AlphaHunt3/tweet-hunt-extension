import React, { useRef, useEffect } from 'react';
import * as d3 from 'd3';
import { HotToken, TokenTreemapNode } from './types';
import { useLocalStorage } from '~storage/useLocalStorage.ts';

// Âü∫‰∫éÊ∂®Ë∑åÂπÖÁîüÊàêÁªøÁ∫¢Ëâ≤Á≥ª
const generateTokenColor = (pricePct24H: number): string => {
  if (pricePct24H >= 0) {
    // Ê∂®ÂπÖÔºöÁªøËâ≤Á≥ªÔºåÊ∂®ÂæóË∂äÂ§öË∂äÊ∑±Áªø
    const intensity = Math.min(Math.abs(pricePct24H) * 5, 1); // Ë∞ÉÊï¥Âº∫Â∫¶ËÆ°ÁÆó
    const lightness = 60 - (intensity * 30); // 60% Âà∞ 30%ÔºåË∂äÊ∂®Ë∂äÊ∑±Áªø
    return `hsl(120, 80%, ${lightness}%)`; // Á∫ØÁªøËâ≤
  } else {
    // Ë∑åÂπÖÔºöÁ∫¢Ëâ≤Á≥ªÔºåË∑åÂæóË∂äÂ§öË∂äÊ∑±Á∫¢
    const intensity = Math.min(Math.abs(pricePct24H) * 5, 1); // Ë∞ÉÊï¥Âº∫Â∫¶ËÆ°ÁÆó
    const lightness = 60 - (intensity * 30); // 60% Âà∞ 30%ÔºåË∂äË∑åË∂äÊ∑±Á∫¢
    return `hsl(0, 80%, ${lightness}%)`; // Á∫ØÁ∫¢Ëâ≤
  }
};

// Ëé∑ÂèñÊéíÂêçËæπÊ°ÜÈ¢úËâ≤ÂíåÂ•ñÁâå
const getRankingStyle = (index: number) => {
  switch (index) {
    case 0: // Á¨¨‰∏ÄÂêç - ÈáëËâ≤
      return {
        strokeColor: '#ffd700',
        strokeWidth: 3,
        trophy: 'ü•á',
        trophyColor: '#ffd700'
      };
    case 1: // Á¨¨‰∫åÂêç - Èì∂Ëâ≤
      return {
        strokeColor: '#c0c0c0',
        strokeWidth: 2.5,
        trophy: 'ü•à',
        trophyColor: '#c0c0c0'
      };
    case 2: // Á¨¨‰∏âÂêç - ÈìúËâ≤
      return {
        strokeColor: '#cd7f32',
        strokeWidth: 2,
        trophy: 'ü•â',
        trophyColor: '#cd7f32'
      };
    default:
      return {
        strokeColor: '#ffffff',
        strokeWidth: 1,
        trophy: null,
        trophyColor: null
      };
  }
};

// Â§ÑÁêÜÊï∞ÊçÆÊØî‰æãÔºåÁ°Æ‰øùÈì∫Êª°Êï¥‰∏™Âå∫Âüü
const processTokensForTreemap = (items: HotToken[]): HotToken[] => {
  // ÂèñÂâç9‰∏™‰ª£Â∏ÅÔºåÈáçÊñ∞ËÆ°ÁÆóÊØî‰æã‰ΩøÂÖ∂Èì∫Êª°Êï¥‰∏™Âå∫Âüü
  const topItems = items.slice(0, 9);
  const totalShare = topItems.reduce((sum, item) => sum + item.share, 0);

  // Âº∫Âà∂Èì∫Êª°ÔºöÂÖàÊåâÊØî‰æãÂàÜÈÖçÔºåÁÑ∂ÂêéÂ∞ÜÂâ©‰ΩôÈù¢ÁßØÂπ≥Êëä
  let processedItems = topItems.map(item => ({
    ...item,
    normalizedShare: item.share / totalShare // ÂΩí‰∏ÄÂåñÊØî‰æã
  }));

  // Á°Æ‰øùÊÄªÂíå‰∏•Ê†ºÁ≠â‰∫é1ÔºåÈÅøÂÖçD3ËÆ°ÁÆóËØØÂ∑Æ
  const currentTotal = processedItems.reduce((sum, item) => sum + item.normalizedShare, 0);
  if (Math.abs(currentTotal - 1) > 0.001) {
    // Â¶ÇÊûúÊÄªÂíå‰∏çÁ≠â‰∫é1ÔºåÊåâÊØî‰æãË∞ÉÊï¥ÊâÄÊúâÈ°πÁõÆ
    const adjustmentFactor = 1 / currentTotal;
    processedItems = processedItems.map(item => ({
      ...item,
      normalizedShare: item.normalizedShare * adjustmentFactor
    }));
  }

  // ÊúÄÂêé‰∏Ä‰∏™È°πÁõÆÊâøÊãÖÂâ©‰ΩôËØØÂ∑ÆÔºåÁ°Æ‰øù‰∏•Ê†ºÈì∫Êª°
  const finalTotal = processedItems.slice(0, -1).reduce((sum, item) => sum + item.normalizedShare, 0);
  if (processedItems.length > 0) {
    processedItems[processedItems.length - 1].normalizedShare = 1 - finalTotal;
  }

  return processedItems;
};

interface TokenTreemapVisualizationProps {
  items: HotToken[];
  loading: boolean;
  width: number;
  height: number;
}

export function TokenTreemapVisualization({ items, loading, width, height }: TokenTreemapVisualizationProps) {
  const svgRef = useRef<SVGSVGElement>(null);
  const [theme] = useLocalStorage('@xhunt/theme', 'dark');

  useEffect(() => {
    if (!svgRef.current || !items.length || loading) return;

    const svg = d3.select(svgRef.current);
    svg.selectAll('*').remove();

    const processedItems = processTokensForTreemap(items);

    // ÂàõÂª∫treemapÂ∏ÉÂ±Ä
    const treemap = d3.treemap<HotToken>()
      .size([width, height])
      .padding(2)
      .round(true);

    // ÂáÜÂ§áÊï∞ÊçÆ
    const root = d3.hierarchy<HotToken>({ children: processedItems } as any)
      .sum(d => {
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂè∂Â≠êËäÇÁÇπÔºàÂÆûÈôÖÊï∞ÊçÆÔºâ
        if ('normalizedShare' in d) {
          return Math.max((d as any).normalizedShare || 0, 0.001);
        }
        return 0;
      })
      .sort((a, b) => (b.value || 0) - (a.value || 0));

    treemap(root);

    // ÂàõÂª∫ÁªÑ - Âè™Â§ÑÁêÜÂè∂Â≠êËäÇÁÇπ
    const leaves = root.leaves() as TokenTreemapNode[];

    // Ê∑ªÂä†defsÂÆö‰πâ
    const defs = svg.append('defs');

    const cell = svg.selectAll('g')
      .data(leaves)
      .enter().append('g')
      .attr('class', 'treemap-cell')
      .attr('transform', d => `translate(${d.x0},${d.y0})`);

    // Ê∑ªÂä†ËÉåÊôØÁü©ÂΩ¢
    cell.append('rect')
      .attr('class', 'treemap-rect')
      .attr('width', d => d.x1 - d.x0)
      .attr('height', d => d.y1 - d.y0)
      .attr('fill', d => generateTokenColor(d.data.pricePct24H))
      .attr('stroke', (d, i) => getRankingStyle(i).strokeColor)
      .attr('stroke-width', (d, i) => getRankingStyle(i).strokeWidth)
      .attr('rx', 6)
      .attr('ry', 6)
      .style('cursor', 'pointer');

    // Ê∑ªÂä†‰∏ªÈ¢òÈÄÇÈÖçÈÅÆÁΩ©
    cell.append('rect')
      .attr('class', 'theme-overlay')
      .attr('width', d => d.x1 - d.x0)
      .attr('height', d => d.y1 - d.y0)
      .attr('fill', theme === 'dark'
        ? 'rgba(15, 23, 42, 0.3)'
        : 'rgba(0, 0, 0, 0.2)')
      .attr('rx', 6)
      .attr('ry', 6);

    // ‰∏∫ÊØè‰∏™tokenÂàõÂª∫ÂõæÊ†ápattern
    leaves.forEach((d, i) => {
      const patternId = `token-icon-pattern-${i}`;

      const nodeWidth = d.x1 - d.x0;
      const nodeHeight = d.y1 - d.y0;
      const area = nodeWidth * nodeHeight;

      // ËÆ°ÁÆóÂ§¥ÂÉèÂ∞∫ÂØ∏Ôºà‰∏éÂêéÁª≠ÁªòÂà∂‰øùÊåÅ‰∏ÄËá¥Ôºâ
      const iconRadius = Math.max(10, Math.min(20, Math.sqrt(area) / 8));
      const diameter = iconRadius * 2;
      const circleCenterX = iconRadius + 12; // Ë∑ùÁ¶ªÂ∑¶ËæπÁºò12px
      const circleCenterY = iconRadius + 12; // Ë∑ùÁ¶ª‰∏äËæπÁºò12px
      const patternX = circleCenterX - iconRadius;
      const patternY = circleCenterY - iconRadius;

      const pattern = defs.append('pattern')
        .attr('id', patternId)
        .attr('patternUnits', 'userSpaceOnUse')
        .attr('x', patternX)
        .attr('y', patternY)
        .attr('width', diameter)
        .attr('height', diameter);

      pattern.append('image')
        .attr('href', d.data.image)
        .attr('x', 0)
        .attr('y', 0)
        .attr('width', diameter)
        .attr('height', diameter)
        .attr('preserveAspectRatio', 'xMidYMid slice');
    });

    // Ê∑ªÂä†‰ª£Â∏ÅÂõæÊ†áÂúÜÂΩ¢
    cell.append('circle')
      .attr('cx', d => {
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        const area = width * height;
        const avatarRadius = Math.max(10, Math.min(20, Math.sqrt(area) / 8));
        return avatarRadius + 12; // Ë∑ùÁ¶ªÂ∑¶ËæπÁºò12px
      })
      .attr('cy', d => {
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        const area = width * height;
        const avatarRadius = Math.max(10, Math.min(20, Math.sqrt(area) / 8));
        return avatarRadius + 12; // Ë∑ùÁ¶ª‰∏äËæπÁºò12px
      })
      .attr('r', d => {
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        const area = width * height;
        return Math.max(10, Math.min(20, Math.sqrt(area) / 8));
      })
      .attr('fill', (d, i) => `url(#token-icon-pattern-${i})`)
      .attr('stroke', 'rgba(255, 255, 255, 0.9)')
      .attr('stroke-width', 2)
      .style('filter', 'drop-shadow(0 2px 4px rgba(0,0,0,0.3))');

    // Ê∑ªÂä†ÊéíÂêçÂ•ñÁâå - Âè™‰∏∫Ââç‰∏âÂêçÊ∑ªÂä†
    cell.filter((d, i) => i < 3)
      .append('text')
      .attr('x', d => (d.x1 - d.x0) - 12)
      .attr('y', 20)
      .attr('text-anchor', 'end')
      .attr('font-size', 24)
      .text((d, i) => getRankingStyle(i).trophy)
      .style('filter', 'drop-shadow(0 1px 2px rgba(0,0,0,0.5))')
      .style('pointer-events', 'none'); // Á¶ÅÁî®Â•ñÁâåÁöÑÈº†Ê†á‰∫ã‰ª∂

    // Ê∑ªÂä†‰ª£Â∏ÅÁ¨¶Âè∑ÊñáÊú¨ - Â∑¶ÂØπÈΩêÔºåÂ∫ïÈÉ®Âå∫Âüü
    cell.append('text')
      .attr('x', 8)
      .attr('y', d => (d.y1 - d.y0) - 32)
      .attr('text-anchor', 'start')
      .attr('font-size', d => {
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        return Math.max(8, Math.min(12, Math.min(width / 12, height / 8)));
      })
      .attr('font-weight', 'bold')
      .attr('fill', '#ffffff')
      .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
      .text(d => {
        const width = d.x1 - d.x0;
        const fontSize = Math.max(8, Math.min(12, Math.min(width / 12, (d.y1 - d.y0) / 8)));
        const maxLength = Math.floor((width - 16) / (fontSize * 0.6)); // ËÄÉËôëÂ∑¶Âè≥ËæπË∑ù
        const symbol = d.data.symbol;
        return symbol.length > maxLength
          ? symbol.substring(0, Math.max(1, maxLength - 3)) + '...'
          : symbol;
      })
      .style('cursor', 'pointer')
      .on('mouseenter', function(event: MouseEvent, d: TokenTreemapNode) {
        // Ëß¶Âèëtoken hover‰∫ã‰ª∂
        const detail = {
          ticker: `$${d.data.symbol}`,
          element: this as unknown as HTMLElement
        };
        window.dispatchEvent(new CustomEvent('xhunt:token-hover', { detail }));
      })
      .on('mouseleave', function(event: MouseEvent, d: TokenTreemapNode) {
        // Ê∏ÖÈô§token hover‰∫ã‰ª∂
        window.dispatchEvent(new CustomEvent('xhunt:token-hover', { detail: null }));
      });

    // Ê∑ªÂä†Ê∂®Ë∑åÂπÖÊñáÊú¨ - Â∑¶ÂØπÈΩêÔºåÁ¨¶Âè∑‰∏ãÊñπ
    cell.append('text')
      .attr('x', 8)
      .attr('y', d => (d.y1 - d.y0) - 16)
      .attr('text-anchor', 'start')
      .attr('font-size', d => {
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        return Math.max(9, Math.min(14, Math.min(width / 10, height / 6)));
      })
      .attr('font-weight', 'bold')
      .attr('fill', d => {
        const pct = d.data.pricePct24H;
        if (pct >= 0) {
          return '#22c55e'; // È≤úÊòéÁªøËâ≤ - ‰∏äÊ∂®
        } else {
          return '#ef4444'; // È≤úÊòéÁ∫¢Ëâ≤ - ‰∏ãË∑å
        }
      })
      .style('text-shadow', '1px 1px 2px rgba(0,0,0,0.8)')
      .text(d => {
        const pct = d.data.pricePct24H * 100;
        const sign = pct >= 0 ? '+' : '';
        return `${sign}${pct.toFixed(1)}%`;
      });

    // ‰∏∫‰ª£Â∏ÅÂ§¥ÂÉèÊ∑ªÂä†hover‰∫ã‰ª∂ÔºåËß¶ÂèëTickerTips
    cell.select('circle')
      .style('cursor', 'pointer')
      .on('mouseenter', function(event: MouseEvent, d: TokenTreemapNode) {
        // Ëß¶Âèëtoken hover‰∫ã‰ª∂
        const detail = {
          ticker: `$${d.data.symbol}`,
          element: this as HTMLElement
        };
        window.dispatchEvent(new CustomEvent('xhunt:token-hover', { detail }));
      })
      .on('mouseleave', function(event: MouseEvent, d: TokenTreemapNode) {
        // Ê∏ÖÈô§token hover‰∫ã‰ª∂
        window.dispatchEvent(new CustomEvent('xhunt:token-hover', { detail: null }));
      });

    // Ê∑ªÂä†ËÉåÊôØË£ÖÈ•∞ - ‰ª£Â∏ÅÁ¨¶Âè∑ÁöÑÂ§ßÂè∑Ê∞¥Âç∞
    cell.append('text')
      .attr('x', d => (d.x1 - d.x0) / 2)
      .attr('y', d => (d.y1 - d.y0) / 2 + 10)
      .attr('text-anchor', 'middle')
      .attr('font-size', d => {
        const width = d.x1 - d.x0;
        const height = d.y1 - d.y0;
        // Â§ßÂè∑Ê∞¥Âç∞Â≠ó‰ΩìÔºåÂç†ÊçÆÂå∫ÂüüÁöÑ1/3Âà∞1/2
        return Math.max(20, Math.min(60, Math.min(width / 3, height / 3)));
      })
      .attr('font-weight', '900')
      .attr('fill', 'rgba(255, 255, 255, 0.08)') // ÊûÅÊ∑°ÁöÑÁôΩËâ≤Ê∞¥Âç∞
      .attr('font-family', 'Arial Black, sans-serif')
      .style('letter-spacing', '2px')
      .style('pointer-events', 'none') // ‰∏çÂΩ±ÂìçÁÇπÂáª‰∫ã‰ª∂
      .text(d => d.data.symbol);

    // Ê∑ªÂä†Ê∏êÂèòË£ÖÈ•∞Á∫øÊù°
    const gradientDefs = svg.select('defs');

    // ÂàõÂª∫Ê∏êÂèòÂÆö‰πâ
    gradientDefs.append('linearGradient')
      .attr('id', 'decorative-gradient')
      .attr('x1', '0%')
      .attr('y1', '0%')
      .attr('x2', '100%')
      .attr('y2', '100%')
      .selectAll('stop')
      .data([
        { offset: '0%', color: 'rgba(255, 255, 255, 0.1)' },
        { offset: '50%', color: 'rgba(255, 255, 255, 0.05)' },
        { offset: '100%', color: 'rgba(255, 255, 255, 0.02)' }
      ])
      .enter().append('stop')
      .attr('offset', d => d.offset)
      .attr('stop-color', d => d.color);

    // Ê∑ªÂä†Ë£ÖÈ•∞ÊÄßÁöÑÂØπËßíÁ∫ø
    cell.append('line')
      .attr('x1', d => (d.x1 - d.x0) * 0.2)
      .attr('y1', d => (d.y1 - d.y0) * 0.8)
      .attr('x2', d => (d.x1 - d.x0) * 0.8)
      .attr('y2', d => (d.y1 - d.y0) * 0.2)
      .attr('stroke', 'url(#decorative-gradient)')
      .attr('stroke-width', 2)
      .style('pointer-events', 'none');

    // Ê∑ªÂä†Â∞èÂúÜÁÇπË£ÖÈ•∞
    cell.append('circle')
      .attr('cx', d => (d.x1 - d.x0) * 0.85)
      .attr('cy', d => (d.y1 - d.y0) * 0.15)
      .attr('r', 3)
      .attr('fill', 'rgba(255, 255, 255, 0.1)')
      .style('pointer-events', 'none');

    cell.append('circle')
      .attr('cx', d => (d.x1 - d.x0) * 0.15)
      .attr('cy', d => (d.y1 - d.y0) * 0.85)
      .attr('r', 2)
      .attr('fill', 'rgba(255, 255, 255, 0.08)')
      .style('pointer-events', 'none');
    // Ê∑ªÂä†hoverÊïàÊûúÂíå‰∫ã‰ª∂
    cell
      .style('cursor', 'pointer')
      .on('mouseenter', function(event: MouseEvent, d: TokenTreemapNode) {
        const cellSelection = d3.select(this);

        // ÈÅÆÁΩ©ÂèòÊ∑°ÔºåËÆ©ËÉåÊôØÊõ¥ÊòéÊòæ
        cellSelection.select('.theme-overlay')
          .transition()
          .duration(300)
          .attr('fill', theme === 'dark'
            ? 'rgba(15, 23, 42, 0.05)'  // hoverÊó∂ÈÅÆÁΩ©ÂèòÂæóÂá†‰πéÈÄèÊòé
            : 'rgba(0, 0, 0, 0.02)');
      })
      .on('mouseleave', function(event: MouseEvent, d: TokenTreemapNode) {
        const cellSelection = d3.select(this);

        // ÈÅÆÁΩ©ÊÅ¢Â§çÂéüÈÄèÊòéÂ∫¶
        cellSelection.select('.theme-overlay')
          .transition()
          .duration(300)
          .attr('fill', theme === 'dark'
            ? 'rgba(15, 23, 42, 0.3)'
            : 'rgba(0, 0, 0, 0.2)');
      })
      .on('click', function(event: MouseEvent, d: TokenTreemapNode) {
        // Ë∑≥ËΩ¨Âà∞TwitterÊêúÁ¥¢ËØ•‰ª£Â∏Å
        const searchUrl = `https://x.com/search?q=${encodeURIComponent(d.data.symbol)}&src=typed_query`;
        window.open(searchUrl, '_blank', 'noopener,noreferrer');
      });
  }, [items, loading, width, height, theme]);

  return (
    <div className="relative overflow-hidden rounded-xl">
      <svg
        ref={svgRef}
        width={width}
        height={height}
        className="w-full h-full cursor-pointer"
      />
    </div>
  );
}
